// MDL v1 utf8
mevislabVersion = 3.6.1.9
network  {
  watchlist = ""
}
module LocalImage {
  internal  {
    frame = "501 677 184 72"
    moduleGroupName = ""
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "603 481 488 148"
        sizeHint = "488 148"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = LocalImage
    name = $(DemoDataPath)/Liver2_MRT_venous.small.dcm
    autoLoad = TRUE
  }
}
module LocalImage {
  internal  {
    frame = "273 669 192 72"
    moduleGroupName = ""
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "603 481 488 148"
        sizeHint = "488 148"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = LocalImage1
    name = $(DemoDataPath)/Liver2_LiverMask.small.tif
    autoLoad = TRUE
  }
}
module Histogram {
  internal  {
    frame = "66 379 120 56"
    moduleGroupName = "Analyze Histogram"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "243 242 400 354"
        sizeHint = "400 354"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = Histogram
    useMask = TRUE
    xRange = "Image Min/Max"
    maskMode = Weights
    curveType = Line
    curveStyle = 0
    curveTitle = ""
    updateMode = Off
    useStepFunction = FALSE
    useZeroAsBinCenter = TRUE
    useBackgroundValue = FALSE
    backgroundValue = 0
    binSize = 1
    maxBinCount = 25000000
  }
}
module CurveGenerator {
  internal  {
    frame = "400 377 152 64"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "2039 187 376 474"
        sizeHint = "376 474"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = GaussianDistribution2
    expression = "c/(sqrt(2*3.1415)*b)*exp(-0.5*(x-a)*(x-a)/(b*b))"
    startValue = 0
    endValue = 600
    stepValue = 1
    errorText = ""
    extValueA = 201.694223443135
    extValueB = 40.165639280533
    extValueC = 0.763708707919496
    extValueD = 0
    extValueE = 0
    extValueF = 0
    extValueG = 0
    extValueH = 0
    extNameA = a
    extNameB = b
    extNameC = c
    extNameD = d
    extNameE = e
    extNameF = f
    extNameG = g
    extNameH = h
    style = 3
    pointCount = 601
    curveName = "Distribution 2"
    expressionComment = ""
    numberOfShownConstants = 3
    editConstantNames = FALSE
  }
}
module ConcatenateCurves {
  internal  {
    frame = "358 291 144 56"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "783 495 129 120"
        sizeHint = "129 120"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = ConcatenateCurves
    enable1 = TRUE
    enable2 = TRUE
    enable3 = TRUE
    enable4 = FALSE
  }
}
module CurveGenerator {
  internal  {
    frame = "240 377 152 64"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "2425 645 617 569"
        sizeHint = "462 569"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = GaussianDistribution1
    expression = "c/(sqrt(2*3.1415)*b)*exp(-0.5*(x-a)*(x-a)/(b*b))"
    startValue = 0
    endValue = 600
    stepValue = 1
    errorText = ""
    extValueA = 98.3718437741612
    extValueB = 28.5513995469314
    extValueC = 0.178308393776013
    extValueD = 0
    extValueE = 0
    extValueF = 0
    extValueG = 0
    extValueH = 0
    extNameA = a
    extNameB = b
    extNameC = c
    extNameD = d
    extNameE = e
    extNameF = f
    extNameG = g
    extNameH = h
    style = 2
    pointCount = 601
    curveName = "Distribution 1"
    expressionComment = ""
    numberOfShownConstants = 3
    editConstantNames = FALSE
  }
}
module View2D {
  internal  {
    frame = "1227 -88 120 56"
    moduleGroupName = "Assign Class Probabilities"
    windows  {
      window _default {
        geometry = "1 308 1224 679"
        sizeHint = "400 400"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = ClassMasks
    inventorInputOn = TRUE
    inventorOutputOn = FALSE
    view2DExtensionsOn = TRUE
    startSlice = 71
    numSlices = 1
    numXSlices = 1
    sliceStep = 1
    slab = 1
    blendMode = BLEND_REPLACE
    timePoint = 0
    maxTimePoint = 0
    filterMode = FILTER_LINEAR
    standardKeys = TRUE
    cineMode = CINE_ZT
    cineDirection = CINE_FORWARD
    cineRepeat = CINE_ONCE
    cineSpeed = 0.1
    cineAlwaysReset = TRUE
    snapToCenter = TRUE
    zoomMode = VIEW2D_AUTO_ZOOM
    unzoomOnImageChange = FALSE
    sliceZoom = 1
    sliceZoomSynced = 1
    baseColor = "1 1 1"
    margin = "2 2"
    sliceOrigin = "0 0"
    useShaders = TRUE
    useManagedInteraction = FALSE
    lutCenter = 236.305603027344
    lutWidth = 541.819519042969
    annotationOn = TRUE
    annotationMode = ANNO_MODE_AUTO
    annotationSizeMode = ANNO_SHOW_DETAILED
    annotationCol = "0.899999976158142 0.899999976158142 0.899999976158142"
    annotationFontSize = ANNO_SIZE_AUTO
    annoCoords = Voxel
    annoCTValue = AsIs
    borderOn = FALSE
    borderColor = "0.899999976158142 0.899999976158142 0.899999976158142"
    valueHighPrecision = TRUE
    showColorChannelValues = FALSE
    colorChannelSeparator = " / "
    maxPrecision = 4
    enableSlicing = TRUE
    useRelativeLUTIfNoInputImage = TRUE
  }
}
module PythonArithmetic {
  internal  {
    frame = "1127 332 128 64"
    moduleGroupName = "Assign Class Probabilities"
    windows  {
      window _default {
        geometry = "88 394 797 531"
        sizeHint = "497 531"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = ProbabilityClass1
    calculateOutputSubImage = "*from numpy import linalg as LA
ext_x, ext_y, ext_z, ext_c, ext_t, ext_u = in0.extent()
pCurve = ctx.parent().field("GaussianDistribution1.outCurve").object()
for u in range(ext_u):
  for t in range(ext_t):
    for c in range(ext_c):
      for z in range(ext_z):
        for y in range(ext_y):
          for x in range(ext_x):
            T = in0[u, t, c, z, y, x] 
            out[u, t, c, z, y, x] = pCurve.getYValue(float(T))*"
    calculateInputSubImageBox = ""
    calculateOutputImageProperties = ""
    numberOfInputs = 2
    doubleConstant0 = 0
    doubleConstant1 = 0
    doubleConstant2 = 0
    doubleConstant3 = 0
    doubleConstant4 = 0
    doubleConstant5 = 0
    doubleConstantName0 = ""
    doubleConstantName1 = ""
    doubleConstantName2 = ""
    doubleConstantName3 = ""
    doubleConstantName4 = ""
    doubleConstantName5 = ""
    intConstant0 = 0
    intConstant1 = 0
    intConstant2 = 0
    intConstant3 = 0
    intConstant4 = 0
    intConstant5 = 0
    intConstantName0 = ""
    intConstantName1 = ""
    intConstantName2 = ""
    intConstantName3 = ""
    intConstantName4 = ""
    intConstantName5 = ""
    setMinMaxValues = FALSE
    minVoxelValue = 0
    maxVoxelValue = 0
    setDataType = FALSE
    dataType = "unsigned int8"
    inputDataType0 = "output type"
    inputDataType1 = "output type"
    inputDataType2 = "output type"
    inputDataType3 = "output type"
    inputDataType4 = "output type"
    inputHandling0 = AllowAny
    inputHandling1 = AllowAny
    inputHandling2 = AllowAny
    inputHandling3 = AllowAny
    inputHandling4 = AllowAny
  }
}
module ImagePropertyConvert {
  internal  {
    frame = "1333 505 152 80"
    moduleGroupName = ""
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "289 605 405 721"
        sizeHint = "381 721"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = ImagePropertyConvert
    changeDimensionInfo = FALSE
    cDimInfo = ""
    tDimInfo = ""
    uDimInfo = ""
    a00 = 1
    a01 = 0
    a02 = 0
    a03 = 0
    a10 = 0
    a11 = 1
    a12 = 0
    a13 = 0
    a20 = 0
    a21 = 0
    a22 = 1
    a23 = 0
    a30 = 0
    a31 = 0
    a32 = 0
    a33 = 1
    worldMatrix = "1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1"
    changeDatatype = TRUE
    datatype = float
    changePageSize = TRUE
    pageSizeX = 92
    pageSizeY = 75
    pageSizeZ = 1
    pageSizeC = 1
    pageSizeT = 1
    pageSizeU = 1
    changeMinGrayValue = FALSE
    minGrayValue = 0
    changeMaxGrayValue = FALSE
    maxGrayValue = 1
    changeWorldMatrix = FALSE
    voxelSizeX = 1
    voxelSizeY = 1
    voxelSizeZ = 1
    autoApply = TRUE
  }
}
module MinMaxScan {
  internal  {
    frame = "1119 232 160 72"
    moduleGroupName = "Assign Class Probabilities"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "1648 937 568 361"
        sizeHint = "545 361"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = MinMaxScan
    updateMode = AutoUpdate
    typeSelect = "Proposed Data Type"
    preferredIntType = PreferUnsigned
  }
}
module PythonArithmetic {
  internal  {
    frame = "1351 324 128 64"
    moduleGroupName = "Assign Class Probabilities"
    windows  {
      window _default {
        geometry = "836 450 736 568"
        sizeHint = "604 568"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = ProbabilityClass2
    calculateOutputSubImage = "*from numpy import linalg as LA
ext_x, ext_y, ext_z, ext_c, ext_t, ext_u = in0.extent()
pCurve = ctx.parent().field("GaussianDistribution2.outCurve").object()
for u in range(ext_u):
  for t in range(ext_t):
    for c in range(ext_c):
      for z in range(ext_z):
        for y in range(ext_y):
          for x in range(ext_x):
            T = in0[u, t, c, z, y, x] 
            out[u, t, c, z, y, x] = pCurve.getYValue(float(T))*"
    calculateInputSubImageBox = ""
    calculateOutputImageProperties = ""
    numberOfInputs = 2
    doubleConstant0 = 0
    doubleConstant1 = 0
    doubleConstant2 = 0
    doubleConstant3 = 0
    doubleConstant4 = 0
    doubleConstant5 = 0
    doubleConstantName0 = ""
    doubleConstantName1 = ""
    doubleConstantName2 = ""
    doubleConstantName3 = ""
    doubleConstantName4 = ""
    doubleConstantName5 = ""
    intConstant0 = 0
    intConstant1 = 0
    intConstant2 = 0
    intConstant3 = 0
    intConstant4 = 0
    intConstant5 = 0
    intConstantName0 = ""
    intConstantName1 = ""
    intConstantName2 = ""
    intConstantName3 = ""
    intConstantName4 = ""
    intConstantName5 = ""
    setMinMaxValues = FALSE
    minVoxelValue = 0
    maxVoxelValue = 0
    setDataType = FALSE
    dataType = "unsigned int8"
    inputDataType0 = "output type"
    inputDataType1 = "output type"
    inputDataType2 = "output type"
    inputDataType3 = "output type"
    inputDataType4 = "output type"
    inputHandling0 = AllowAny
    inputHandling1 = AllowAny
    inputHandling2 = AllowAny
    inputHandling3 = AllowAny
    inputHandling4 = AllowAny
  }
}
module MinMaxScan {
  internal  {
    frame = "1351 224 160 72"
    moduleGroupName = "Assign Class Probabilities"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "622 399 472 314"
        sizeHint = "449 314"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = MinMaxScan1
    updateMode = AutoUpdate
    typeSelect = "Proposed Data Type"
    preferredIntType = PreferUnsigned
  }
}
module SoView2DOverlay {
  internal  {
    frame = "1347 136 168 56"
    moduleGroupName = "Assign Class Probabilities"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "1509 526 436 448"
        sizeHint = "436 448"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = SoView2DOverlay
    interactionProviderID = ""
    drawingOn = TRUE
    editingOn = TRUE
    fixZOn = TRUE
    color = "1 1 1"
    selectionTolerance = 4
    needsValidVoxel = TRUE
    button1 = IGNORED
    button2 = IGNORED
    button3 = IGNORED
    shift = IGNORED
    control = IGNORED
    alt = IGNORED
    wantsAllEvents = TRUE
    wantsKeyEvents = TRUE
    wantsMouseWheelEvents = FALSE
    setEventHandled = FALSE
    ignoreHandledEvents = FALSE
    createNewMode = FALSE
    renderOnSlab = TRUE
    clipToSlice = TRUE
    cursorShape = UNDEFINED_CURSOR
    overlayName = ""
    cacheTextures = TRUE
    blendMode = BLEND_ADD
    overwriteCurrentTimePoint = FALSE
    timePoint = 0
    maxTimePoint = 0
    filterMode = FILTER_LINEAR
    inheritFilterMode = TRUE
    lutPrecision = VIEW2D_LUT_AUTO
    alphaFactor = 1
    baseColor = "1 0.666666686534882 0"
    useWorldCoords = TRUE
    applyLut = TRUE
    isCheckerTiling = FALSE
    checkerTileSize = 2
    areCheckerTilesInverted = FALSE
  }
}
module SoView2DOverlay {
  internal  {
    frame = "1115 144 168 56"
    moduleGroupName = "Assign Class Probabilities"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "1509 526 436 448"
        sizeHint = "436 448"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = SoView2DOverlay1
    interactionProviderID = ""
    drawingOn = TRUE
    editingOn = TRUE
    fixZOn = TRUE
    color = "1 1 1"
    selectionTolerance = 4
    needsValidVoxel = TRUE
    button1 = IGNORED
    button2 = IGNORED
    button3 = IGNORED
    shift = IGNORED
    control = IGNORED
    alt = IGNORED
    wantsAllEvents = TRUE
    wantsKeyEvents = TRUE
    wantsMouseWheelEvents = FALSE
    setEventHandled = FALSE
    ignoreHandledEvents = FALSE
    createNewMode = FALSE
    renderOnSlab = TRUE
    clipToSlice = TRUE
    cursorShape = UNDEFINED_CURSOR
    overlayName = ""
    cacheTextures = TRUE
    blendMode = BLEND_ADD
    overwriteCurrentTimePoint = FALSE
    timePoint = 0
    maxTimePoint = 0
    filterMode = FILTER_LINEAR
    inheritFilterMode = TRUE
    lutPrecision = VIEW2D_LUT_AUTO
    alphaFactor = 1
    baseColor = "0 0.666666686534882 1"
    useWorldCoords = TRUE
    applyLut = TRUE
    isCheckerTiling = FALSE
    checkerTileSize = 2
    areCheckerTilesInverted = FALSE
  }
}
module SoGroup {
  internal  {
    frame = "1263 16 128 56"
    moduleGroupName = "Assign Class Probabilities"
    windows  {
      window _viewer {
        geometry = "1074 397 400 400"
        sizeHint = "400 400"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = SoGroup
  }
}
module RunPythonScript {
  internal  {
    frame = "-92 161 160 64"
    moduleGroupName = "Analyze Histogram"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "607 327 1277 1351"
        sizeHint = "745 321"
        wasOpen = no
      }
      window _automatic {
        geometry = "1030 457 500 600"
        sizeHint = "256 192"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = EMAlgorithm
    in0 = ""
    in1 = ""
    in2 = ""
    in3 = ""
    in4 = ""
    in5 = ""
    in6 = ""
    in7 = ""
    in8 = ""
    in9 = ""
    inComment0 = in0
    inComment1 = in1
    inComment2 = in2
    inComment3 = in3
    inComment4 = in4
    inComment5 = in5
    inComment6 = in6
    inComment7 = in7
    inComment8 = in8
    inComment9 = in9
    autoApply0 = FALSE
    autoApply1 = TRUE
    autoApply2 = TRUE
    autoApply3 = TRUE
    autoApply4 = TRUE
    autoApply5 = TRUE
    autoApply6 = TRUE
    autoApply7 = TRUE
    autoApply8 = TRUE
    autoApply9 = TRUE
    out0 = 0
    out1 = 0
    out2 = 0
    out3 = 0
    out4 = 0
    out5 = 0
    out6 = 0
    out7 = 0
    out8 = 0
    out9 = 0
    outComment0 = out0
    outComment1 = out1
    outComment2 = out2
    outComment3 = out3
    outComment4 = out4
    outComment5 = out5
    outComment6 = out6
    outComment7 = out7
    outComment8 = out8
    outComment9 = out9
    initCode = "# For backward compatibility, set up CTX as alias for ctx
CTX = ctx # ctx is the network's context, not RunPythonScript's"
    wakeUpCode = ""
    code = "*import numpy as np
import math

# Reset Gaussian modules
for module_idx in range(4):
    gaussian_module = ctx.module("GaussianDistribution{}".format(module_idx+1))
    parameter_names = ('extValueA', 'extValueB', 'extValueC')
    for param_name in parameter_names:
        gaussian_module.field(param_name).value = 0.0

# Get histogram curve data
ctx.field("Histogram.update").touch()
histogram_curve = ctx.field("HistogramParameters.outputHistogramCurve").object()
x_minimum = histogram_curve.getXMin()
x_maximum = histogram_curve.getXMax()
data_range = x_maximum - x_minimum

# Calculate total histogram sum
total_histogram_count = 0.0
for i in range(histogram_curve.getNumPoints()):
    total_histogram_count += histogram_curve.getYValue(i)

# Setup initial class parameters - CHANGEABLE
NUMBER_OF_CLASSES = 3
class_params = []
for class_id in range(NUMBER_OF_CLASSES):
    initial_mean = x_minimum + (class_id + 0.5) * data_range / NUMBER_OF_CLASSES
    initial_std = math.sqrt(data_range / NUMBER_OF_CLASSES)
    initial_weight = 1.0
    class_params.append([initial_mean, initial_std, initial_weight])
    print("Init class {}: mean {}, sigma {}, a priori prob {}".format(class_id, initial_mean, initial_std, initial_weight))

# Configure curve concatenation
for idx in range(4):
    enable_flag = True if idx < NUMBER_OF_CLASSES else False
    ctx.field("ConcatenateCurves.enable{}".format(idx+1)).value = enable_flag

# Convergence settings
error_difference = histogram_curve.getYMax()
convergence_epsilon = error_difference / 100000.0
maximum_iterations = 200

iteration_counter = 0
current_error = 0.0
previous_error = 0.0

# Initialize responsibility matrix
class_responsibilities = []
for class_idx in range(NUMBER_OF_CLASSES):
    responsibility_row = []
    for point_idx in range(histogram_curve.getNumPoints()):
        responsibility_row.append(0.0)
    class_responsibilities.append(responsibility_row)

print('EM expecting {} classes'.format(NUMBER_OF_CLASSES))

# Main EM algorithm loop
while (iteration_counter < maximum_iterations) and (convergence_epsilon < error_difference):
    print('Iteration {}, current difference {}'.format(iteration_counter, error_difference))
    
    # E-STEP: Calculate class probabilities for each histogram bin
    for bin_idx in range(histogram_curve.getNumPoints()):
        x_value = histogram_curve.getXValue(bin_idx)
        observed_count = histogram_curve.getYValue(bin_idx)
        
        total_likelihood = 0.0
        class_likelihoods = []
        
        # Calculate likelihood for each class
        for class_idx in range(NUMBER_OF_CLASSES):
            class_mean = class_params[class_idx][0]
            class_sigma = class_params[class_idx][1]
            class_prior = class_params[class_idx][2]
            
            if class_sigma > 0.0:
                # Gaussian PDF calculation
                variance = class_sigma * class_sigma
                pdf_coefficient = class_prior / math.sqrt(2.0 * math.pi * variance)
                pdf_exponent = -0.5 * ((x_value - class_mean) * (x_value - class_mean)) / variance
                likelihood = pdf_coefficient * math.exp(pdf_exponent)
                class_likelihoods.append(likelihood)
                total_likelihood += likelihood
            else:
                class_likelihoods.append(0.0)
        
        # Normalize and assign responsibilities
        if total_likelihood > 0:
            for class_idx in range(NUMBER_OF_CLASSES):
                normalized_prob = class_likelihoods[class_idx] / total_likelihood
                class_responsibilities[class_idx][bin_idx] = observed_count * normalized_prob
        
        current_error += (total_likelihood - observed_count) * (total_likelihood - observed_count)
    
    # M-STEP: Update class parameters
    updated_class_params = []
    for class_idx in range(NUMBER_OF_CLASSES):
        updated_class_params.append([0.0, 0.0, 0.0])
    
    # Calculate effective sample sizes and weighted means
    for bin_idx in range(histogram_curve.getNumPoints()):
        x_value = histogram_curve.getXValue(bin_idx)
        for class_idx in range(NUMBER_OF_CLASSES):
            responsibility = class_responsibilities[class_idx][bin_idx]
            updated_class_params[class_idx][2] += responsibility  # effective sample size
            updated_class_params[class_idx][0] += x_value * responsibility  # weighted mean sum
    
    # Calculate new means
    for class_idx in range(NUMBER_OF_CLASSES):
        effective_size = updated_class_params[class_idx][2]
        if effective_size > 0.00001:
            updated_class_params[class_idx][0] = updated_class_params[class_idx][0] / effective_size
        else:
            updated_class_params[class_idx][0] = class_params[class_idx][0]  # keep old mean
    
    # Calculate new variances
    for bin_idx in range(histogram_curve.getNumPoints()):
        x_value = histogram_curve.getXValue(bin_idx)
        for class_idx in range(NUMBER_OF_CLASSES):
            responsibility = class_responsibilities[class_idx][bin_idx]
            mean_diff = x_value - updated_class_params[class_idx][0]
            updated_class_params[class_idx][1] += responsibility * mean_diff * mean_diff
    
    # Finalize parameter updates
    for class_idx in range(NUMBER_OF_CLASSES):
        effective_size = updated_class_params[class_idx][2]
        variance_sum = updated_class_params[class_idx][1]
        
        if (variance_sum > 0.00001) and (effective_size > 0.00001):
            updated_class_params[class_idx][1] = math.sqrt(variance_sum / effective_size)  # new sigma
            updated_class_params[class_idx][2] = effective_size / total_histogram_count  # new prior
        else:
            updated_class_params[class_idx][1] = 0.0
            updated_class_params[class_idx][2] = 0.0
    
    # Calculate convergence measure
    normalized_error = math.sqrt(current_error / float(histogram_curve.getNumPoints()))
    error_difference = abs(normalized_error - previous_error)
    previous_error = normalized_error
    
    # Update parameters for next iteration
    for class_idx in range(NUMBER_OF_CLASSES):
        class_params[class_idx] = updated_class_params[class_idx]
        print("Update class {}: mean {}, sigma {}, a priori prob {}".format(
            class_idx, class_params[class_idx][0], class_params[class_idx][1], class_params[class_idx][2]))
    
    iteration_counter += 1

# Update Gaussian distribution modules with final parameters
for class_idx in range(NUMBER_OF_CLASSES):
    gaussian_module = ctx.module("GaussianDistribution{}".format(class_idx+1))
    parameter_fields = ('extValueA', 'extValueB', 'extValueC')
    for param_idx, field_name in enumerate(parameter_fields):
        gaussian_module.field(field_name).value = class_params[class_idx][param_idx]

# Trigger final updates
ctx.field("EstimatedHistogram.update").touch()

for module_idx in range(4):
    ctx.field("ProbabilityClass{}.update".format(module_idx+1)).touch()*"
    finalizeCode = ""
    showFields = FALSE
    showInitCode = FALSE
    showWakeUpCode = FALSE
    showCode = TRUE
    showFinalizeCode = FALSE
    showConsole = FALSE
  }
}
module HistogramParameters {
  internal  {
    frame = "42 283 152 56"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "2017 427 770 835"
        sizeHint = "659 835"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = HistogramParameters
    normalize = TRUE
    normalize100 = FALSE
    quantileArg = 5
    quantile2Arg = 95
    fwhmPosition = 1
    startPos = 0
    endPos = 0
    useStepFunction = FALSE
  }
}
module CurveGenerator {
  internal  {
    frame = "560 377 152 64"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "2257 693 462 569"
        sizeHint = "462 569"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = GaussianDistribution3
    expression = "c/(sqrt(2*3.1415)*b)*exp(-0.5*(x-a)*(x-a)/(b*b))"
    startValue = 0
    endValue = 600
    stepValue = 1
    errorText = ""
    extValueA = 266.36592513611
    extValueB = 60.4847092707447
    extValueC = 0.0579828983044916
    extValueD = 0
    extValueE = 0
    extValueF = 0
    extValueG = 0
    extValueH = 0
    extNameA = a
    extNameB = b
    extNameC = c
    extNameD = d
    extNameE = e
    extNameF = f
    extNameG = g
    extNameH = h
    style = 4
    pointCount = 601
    curveName = "Distribution 3"
    expressionComment = ""
    numberOfShownConstants = 3
    editConstantNames = FALSE
  }
}
module SoDiagram2D {
  internal  {
    frame = "348 -131 112 56"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "393 869 543 644"
        sizeHint = "543 644"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = SoDiagram2D
    minX = 0
    maxX = 620
    minY = 0
    maxY = 0.00838036174535491
    scaleX = 1
    scaleY = 1
    autoRangeX = TRUE
    autoRangeY = TRUE
    axisColor = "1 1 1"
    axisRotation = AXIS_ROTATION_LEFT_BOTTOM
    titleFontHeight = 14
    drawDiagramTitle = FALSE
    diagramTitleString = ""
    drawGrid = FALSE
    gridColor = "0.349999994039536 0.349999994039536 0.349999994039536"
    drawLegend = TRUE
    legendPlacement = LEGEND_UPPER_RIGHT
    legendFontHeight = 12
    autoLimitLegendFontHeight = FALSE
    zoomAnimationEase = 0.5
    zoomAnimationEpsilon = 0.0099999998
    useZoomRestrictions = FALSE
    minZoomFactor = 0.1
    maxZoomFactor = 10
    drawChildrenExtensions = TRUE
    forwardEventsToChildrenExtensions = TRUE
    changeLineOpacityForHighlightedCurves = FALSE
    curveLineOpacityHighlighted = 1
    changeAreaOpacityForHighlightedCurves = FALSE
    curveAreaOpacityHighlighted = 1
    changeLineOpacityForNotHighlightedCurves = FALSE
    curveLineOpacityNotHighlighted = 0.30000001
    changeAreaOpacityForNotHighlightedCurves = FALSE
    curveAreaOpacityNotHighlighted = 0.30000001
    changeLineStyleForHighlightedCurves = FALSE
    curveLineStyleHighlighted = 1
    changeLineStyleForNotHighlightedCurves = FALSE
    curveLineStyleNotHighlighted = 1
    changeLineWidthForHighlightedCurves = FALSE
    curveLineWidthHighlighted = 1
    changeLineWidthForNotHighlightedCurves = FALSE
    curveLineWidthNotHighlighted = 1
    curveIndexHighlighted = ""
    reorderHighlightedCurves = FALSE
    borderH = 44
    borderV = 28
    autoBorderH = TRUE
    autoBorderV = TRUE
    drawAxisX = TRUE
    drawAxisY = TRUE
    drawTicksX = TRUE
    drawTicksY = TRUE
    drawLabelsX = TRUE
    drawLabelsY = TRUE
    drawAxisTitleX = FALSE
    drawAxisTitleY = FALSE
    axisTitleStringX = "X [dn]"
    axisTitleStringY = "Y [dn]"
    axisTitleFontHeightX = 12
    axisTitleFontHeightY = 12
    axisLabelFontHeightX = 12
    axisLabelFontHeightY = 12
    tickMinDistance = 30
    curveColor = "1 1 1"
    lineStyle = LINE_STYLE_SOLID
    markerType = MARKER_TYPE_NONE
    markerSize = 10
    lineWidth = 1
    antiAlias = TRUE
    areaOpacity = 0.5
    lineOpacity = 1
    stylePaletteMode = STYLE_PALETTE_INDEX
  }
}
module SoRenderArea {
  internal  {
    frame = "332 -207 144 64"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _viewer {
        geometry = "1400 726 1042 400"
        sizeHint = "400 400"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = DistributionsDiagram
    renderCaching = AUTO
    boundingBoxCaching = AUTO
    renderCulling = AUTO
    pickCulling = AUTO
    border = FALSE
    background = "0 0 0"
    transparency = BLEND
    antialiasing = FALSE
    antialiasingNumPasses = 1
    useSampleBuffers = FALSE
    numSamples = 8
    grabKeyFocus = TRUE
    enableKeyCommands = TRUE
    snapshotFormat = SNAPSHOT_RGB
    outputAviFile = ""
    autoRedrawWhenRecording = TRUE
    frameRate = 7
    frameRateAvi = 15
    outputSnapshotFile = none
    outputSnapshotFileWritten = none
    autoIncreaseFile = TRUE
    showSnapshotWithShell = FALSE
    snapCount = 0
    inputDevicesList = ""
  }
}
module StylePalette {
  internal  {
    frame = "494 195 96 56"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "1352 161 978 620"
        sizeHint = "750 620"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = StylePalette
    color1 = "1 1 0"
    color2 = "0 0.666666666666667 1"
    color3 = "1 0.666666666666667 0"
    color4 = "0 0.666666666666667 0"
    color5 = "1 0.5 0"
    color6 = "1 0 1"
    color7 = "0 1 1"
    color8 = "0.5 1 0.5"
    color9 = "1 0 0.5"
    color10 = "0.5 1 0"
    color11 = "0.5 0 1"
    color12 = "0 1 0.5"
    lineStyle1 = Solid
    lineStyle2 = Solid
    lineStyle3 = Solid
    lineStyle4 = Solid
    lineStyle5 = Solid
    lineStyle6 = Solid
    lineStyle7 = Solid
    lineStyle8 = Solid
    lineStyle9 = Solid
    lineStyle10 = Solid
    lineStyle11 = Solid
    lineStyle12 = Solid
    lineWidth1 = 1
    lineWidth2 = 1
    lineWidth3 = 1
    lineWidth4 = 1
    lineWidth5 = 1
    lineWidth6 = 1
    lineWidth7 = 1
    lineWidth8 = 1
    lineWidth9 = 1
    lineWidth10 = 1
    lineWidth11 = 1
    lineWidth12 = 1
    markerType1 = None
    markerType2 = None
    markerType3 = None
    markerType4 = None
    markerType5 = None
    markerType6 = None
    markerType7 = None
    markerType8 = None
    markerType9 = None
    markerType10 = None
    markerType11 = None
    markerType12 = None
    markerSize1 = 4
    markerSize2 = 4
    markerSize3 = 4
    markerSize4 = 4
    markerSize5 = 4
    markerSize6 = 4
    markerSize7 = 4
    markerSize8 = 4
    markerSize9 = 4
    markerSize10 = 4
    markerSize11 = 4
    markerSize12 = 4
    antiAlias1 = FALSE
    antiAlias2 = FALSE
    antiAlias3 = FALSE
    antiAlias4 = FALSE
    antiAlias5 = FALSE
    antiAlias6 = FALSE
    antiAlias7 = FALSE
    antiAlias8 = FALSE
    antiAlias9 = FALSE
    antiAlias10 = FALSE
    antiAlias11 = FALSE
    antiAlias12 = FALSE
    name1 = ""
    name2 = ""
    name3 = ""
    name4 = ""
    name5 = ""
    name6 = ""
    name7 = ""
    name8 = ""
    name9 = ""
    name10 = ""
    name11 = ""
    name12 = ""
    currentStyle = 0
    currentColor = "1 1 1"
    currentLineStyle = None
    currentLineWidth = 1
    currentMarkerType = None
    currentMarkerSize = 4
    currentAntiAlias = FALSE
    currentName = ""
    reservedEntries = 0
  }
}
module ConcatenateCurves {
  internal  {
    frame = "276 -51 144 56"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "783 495 129 120"
        sizeHint = "129 120"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = ConcatenateCurves1
    enable1 = FALSE
    enable2 = TRUE
    enable3 = TRUE
    enable4 = TRUE
  }
}
module PythonArithmetic {
  internal  {
    frame = "1559 332 128 64"
    moduleGroupName = "Assign Class Probabilities"
    windows  {
      window _default {
        geometry = "120 316 618 571"
        sizeHint = "486 571"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = ProbabilityClass3
    calculateOutputSubImage = "*from numpy import linalg as LA
ext_x, ext_y, ext_z, ext_c, ext_t, ext_u = in0.extent()
pCurve = ctx.parent().field("GaussianDistribution3.outCurve").object()
for u in range(ext_u):
  for t in range(ext_t):
    for c in range(ext_c):
      for z in range(ext_z):
        for y in range(ext_y):
          for x in range(ext_x):
            T = in0[u, t, c, z, y, x] 
            out[u, t, c, z, y, x] = pCurve.getYValue(float(T))*"
    calculateInputSubImageBox = ""
    calculateOutputImageProperties = ""
    numberOfInputs = 2
    doubleConstant0 = 0
    doubleConstant1 = 0
    doubleConstant2 = 0
    doubleConstant3 = 0
    doubleConstant4 = 0
    doubleConstant5 = 0
    doubleConstantName0 = ""
    doubleConstantName1 = ""
    doubleConstantName2 = ""
    doubleConstantName3 = ""
    doubleConstantName4 = ""
    doubleConstantName5 = ""
    intConstant0 = 0
    intConstant1 = 0
    intConstant2 = 0
    intConstant3 = 0
    intConstant4 = 0
    intConstant5 = 0
    intConstantName0 = ""
    intConstantName1 = ""
    intConstantName2 = ""
    intConstantName3 = ""
    intConstantName4 = ""
    intConstantName5 = ""
    setMinMaxValues = FALSE
    minVoxelValue = 0
    maxVoxelValue = 0
    setDataType = FALSE
    dataType = "unsigned int8"
    inputDataType0 = "output type"
    inputDataType1 = "output type"
    inputDataType2 = "output type"
    inputDataType3 = "output type"
    inputDataType4 = "output type"
    inputHandling0 = AllowAny
    inputHandling1 = AllowAny
    inputHandling2 = AllowAny
    inputHandling3 = AllowAny
    inputHandling4 = AllowAny
  }
}
module MinMaxScan {
  internal  {
    frame = "1559 232 160 72"
    moduleGroupName = "Assign Class Probabilities"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "622 399 472 314"
        sizeHint = "449 314"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = MinMaxScan2
    updateMode = AutoUpdate
    typeSelect = "Proposed Data Type"
    preferredIntType = PreferUnsigned
  }
}
module SoView2DOverlay {
  internal  {
    frame = "1555 144 168 56"
    moduleGroupName = "Assign Class Probabilities"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "1509 526 436 448"
        sizeHint = "436 448"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = SoView2DOverlay2
    interactionProviderID = ""
    drawingOn = TRUE
    editingOn = TRUE
    fixZOn = TRUE
    color = "1 1 1"
    selectionTolerance = 4
    needsValidVoxel = TRUE
    button1 = IGNORED
    button2 = IGNORED
    button3 = IGNORED
    shift = IGNORED
    control = IGNORED
    alt = IGNORED
    wantsAllEvents = TRUE
    wantsKeyEvents = TRUE
    wantsMouseWheelEvents = FALSE
    setEventHandled = FALSE
    ignoreHandledEvents = FALSE
    createNewMode = FALSE
    renderOnSlab = TRUE
    clipToSlice = TRUE
    cursorShape = UNDEFINED_CURSOR
    overlayName = ""
    cacheTextures = TRUE
    blendMode = BLEND_ADD
    overwriteCurrentTimePoint = FALSE
    timePoint = 0
    maxTimePoint = 0
    filterMode = FILTER_LINEAR
    inheritFilterMode = TRUE
    lutPrecision = VIEW2D_LUT_AUTO
    alphaFactor = 1
    baseColor = "0 0.666666686534882 0"
    useWorldCoords = TRUE
    applyLut = TRUE
    isCheckerTiling = FALSE
    checkerTileSize = 2
    areCheckerTilesInverted = FALSE
  }
}
module CurveGenerator {
  internal  {
    frame = "736 377 152 64"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "2155 796 462 569"
        sizeHint = "462 569"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = GaussianDistribution4
    expression = "c/(sqrt(2*3.1415)*b)*exp(-0.5*(x-a)*(x-a)/(b*b))"
    startValue = 0
    endValue = 600
    stepValue = 1
    errorText = ""
    extValueA = 0
    extValueB = 0
    extValueC = 0
    extValueD = 0
    extValueE = 0
    extValueF = 0
    extValueG = 0
    extValueH = 0
    extNameA = a
    extNameB = b
    extNameC = c
    extNameD = d
    extNameE = e
    extNameF = f
    extNameG = g
    extNameH = h
    style = 5
    pointCount = 601
    curveName = "Distribution 4"
    expressionComment = ""
    numberOfShownConstants = 3
    editConstantNames = FALSE
  }
}
module CurveProperties {
  internal  {
    frame = "272 93 120 56"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "1052 668 494 179"
        sizeHint = "457 179"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = CurveProperties
    applyStyle = FALSE
    style = 1
    applyType = FALSE
    type = Line
    applyTitle = TRUE
    title = "Sum of distributions"
    applyUnit = FALSE
    unit = ""
    applySymbol = FALSE
    symbol = ""
  }
}
module CurveProperties {
  internal  {
    frame = "84 85 128 56"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "1052 668 494 179"
        sizeHint = "457 179"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = CurveProperties1
    applyStyle = FALSE
    style = 1
    applyType = FALSE
    type = Line
    applyTitle = TRUE
    title = Histogram
    applyUnit = FALSE
    unit = ""
    applySymbol = FALSE
    symbol = ""
  }
}
module PythonArithmetic {
  internal  {
    frame = "1785 353 128 64"
    moduleGroupName = "Assign Class Probabilities"
    windows  {
      window _default {
        geometry = "120 316 618 571"
        sizeHint = "486 571"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = ProbabilityClass4
    calculateOutputSubImage = "*from numpy import linalg as LA
ext_x, ext_y, ext_z, ext_c, ext_t, ext_u = in0.extent()
pCurve = ctx.parent().field("GaussianDistribution4.outCurve").object()
for u in range(ext_u):
  for t in range(ext_t):
    for c in range(ext_c):
      for z in range(ext_z):
        for y in range(ext_y):
          for x in range(ext_x):
            T = in0[u, t, c, z, y, x] 
            out[u, t, c, z, y, x] = pCurve.getYValue(float(T))*"
    calculateInputSubImageBox = ""
    calculateOutputImageProperties = ""
    numberOfInputs = 2
    doubleConstant0 = 0
    doubleConstant1 = 0
    doubleConstant2 = 0
    doubleConstant3 = 0
    doubleConstant4 = 0
    doubleConstant5 = 0
    doubleConstantName0 = ""
    doubleConstantName1 = ""
    doubleConstantName2 = ""
    doubleConstantName3 = ""
    doubleConstantName4 = ""
    doubleConstantName5 = ""
    intConstant0 = 0
    intConstant1 = 0
    intConstant2 = 0
    intConstant3 = 0
    intConstant4 = 0
    intConstant5 = 0
    intConstantName0 = ""
    intConstantName1 = ""
    intConstantName2 = ""
    intConstantName3 = ""
    intConstantName4 = ""
    intConstantName5 = ""
    setMinMaxValues = FALSE
    minVoxelValue = 0
    maxVoxelValue = 0
    setDataType = FALSE
    dataType = "unsigned int8"
    inputDataType0 = "output type"
    inputDataType1 = "output type"
    inputDataType2 = "output type"
    inputDataType3 = "output type"
    inputDataType4 = "output type"
    inputHandling0 = AllowAny
    inputHandling1 = AllowAny
    inputHandling2 = AllowAny
    inputHandling3 = AllowAny
    inputHandling4 = AllowAny
  }
}
module MinMaxScan {
  internal  {
    frame = "1769 229 160 72"
    moduleGroupName = "Assign Class Probabilities"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "622 399 468 313"
        sizeHint = "450 313"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = MinMaxScan3
    updateMode = AutoUpdate
    typeSelect = "Proposed Data Type"
    preferredIntType = PreferUnsigned
  }
}
module SoView2DOverlay {
  internal  {
    frame = "1765 141 168 56"
    moduleGroupName = "Assign Class Probabilities"
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "1509 526 436 448"
        sizeHint = "436 448"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = SoView2DOverlay3
    interactionProviderID = ""
    drawingOn = TRUE
    editingOn = TRUE
    fixZOn = TRUE
    color = "1 1 1"
    selectionTolerance = 4
    needsValidVoxel = TRUE
    button1 = IGNORED
    button2 = IGNORED
    button3 = IGNORED
    shift = IGNORED
    control = IGNORED
    alt = IGNORED
    wantsAllEvents = TRUE
    wantsKeyEvents = TRUE
    wantsMouseWheelEvents = FALSE
    setEventHandled = FALSE
    ignoreHandledEvents = FALSE
    createNewMode = FALSE
    renderOnSlab = TRUE
    clipToSlice = TRUE
    cursorShape = UNDEFINED_CURSOR
    overlayName = ""
    cacheTextures = TRUE
    blendMode = BLEND_BLEND
    overwriteCurrentTimePoint = FALSE
    timePoint = 0
    maxTimePoint = 0
    filterMode = FILTER_LINEAR
    inheritFilterMode = TRUE
    lutPrecision = VIEW2D_LUT_AUTO
    alphaFactor = 0.80000001
    baseColor = "0.666666686534882 0.333333343267441 1"
    useWorldCoords = TRUE
    applyLut = TRUE
    isCheckerTiling = FALSE
    checkerTileSize = 2
    areCheckerTilesInverted = FALSE
  }
}
module AddCurves {
  internal  {
    frame = "228 201 144 64"
    moduleGroupName = "Analyze Histogram"
    windows  {
      window _default {
        geometry = "1720 995 454 245"
        sizeHint = "401 245"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = EstimatedHistogram
    onInputChangeBehavior = Clear
  }
}
module MergeRegions {
  internal  {
    frame = "265 533 192 72"
    moduleGroupName = ""
    showNetworkPanel = true
    windows  {
      window _default {
        geometry = "758 533 1044 448"
        sizeHint = "1044 448"
        wasOpen = no
      }
    }
  }
  fields  {
    instanceName = MergeRegions
    outWorldBox = "-194.3205 -153.5655 -130.365 0 0 0 93.1795 80.8095 85.635 0 0 0"
    fillValue = 0
    selectROI = UseInputRegion
    roiSourceIndex = 0
    numActiveImages = 2
    allowInvalidInputs = FALSE
    allowDifferentInputImageGridsInCopyMode = FALSE
    worldToVoxelGridConversionTolerance = 0.001
    mergeImgMode = None
    c0 = 0
    useC0 = TRUE
    c1 = 0
    useC1 = TRUE
    c2 = 0
    useC2 = TRUE
    c3 = 0
    useC3 = TRUE
    c4 = 0
    useC4 = TRUE
    c5 = 0
    useC5 = TRUE
    c6 = 0
    useC6 = TRUE
    c7 = 0
    useC7 = TRUE
    c8 = 0
    useC8 = TRUE
    c9 = 0
    useC9 = TRUE
    c10 = 0
    useC10 = TRUE
    c11 = 0
    useC11 = TRUE
    c12 = 0
    useC12 = TRUE
    c13 = 0
    useC13 = TRUE
    c14 = 0
    useC14 = TRUE
    c15 = 0
    useC15 = TRUE
    c16 = 0
    useC16 = TRUE
    c17 = 0
    useC17 = TRUE
    c18 = 0
    useC18 = TRUE
    c19 = 0
    useC19 = TRUE
    autoUpdate = TRUE
  }
}
connections  {
  Histogram.input0 = MergeRegions.output0
  Histogram.input1 = MergeRegions.output1
  ConcatenateCurves.inCurve1 = GaussianDistribution1.outCurve
  ConcatenateCurves.inCurve2 = GaussianDistribution2.outCurve
  ConcatenateCurves.inCurve3 = GaussianDistribution3.outCurve
  ConcatenateCurves.inCurve4 = GaussianDistribution4.outCurve
  ClassMasks.inImage = LocalImage.outImage
  ClassMasks.inInvPreLUT = SoGroup.self
  ProbabilityClass1.input0 = ImagePropertyConvert.output0
  ImagePropertyConvert.input0 = LocalImage.outImage
  MinMaxScan.input0 = ProbabilityClass1.output0
  ProbabilityClass2.input0 = ImagePropertyConvert.output0
  MinMaxScan1.input0 = ProbabilityClass2.output0
  SoView2DOverlay.image = MinMaxScan1.output0
  SoView2DOverlay1.image = MinMaxScan.output0
  SoGroup.children = "SoView2DOverlay1.self SoView2DOverlay.self SoView2DOverlay2.self SoView2DOverlay3.self"
  HistogramParameters.inHistogram = Histogram.outputHistogram
  SoDiagram2D.inCurveList = ConcatenateCurves1.outCurveList
  SoDiagram2D.inStylePalette = StylePalette.outStylePalette
  DistributionsDiagram.children = SoDiagram2D.self
  ConcatenateCurves1.inCurve2 = CurveProperties1.outCurves
  ConcatenateCurves1.inCurve3 = CurveProperties.outCurves
  ConcatenateCurves1.inCurve4 = ConcatenateCurves.outCurveList
  ProbabilityClass3.input0 = ImagePropertyConvert.output0
  MinMaxScan2.input0 = ProbabilityClass3.output0
  SoView2DOverlay2.image = MinMaxScan2.output0
  CurveProperties.inCurves = EstimatedHistogram.outCurveList
  CurveProperties1.inCurves = HistogramParameters.outHistogramCurve
  ProbabilityClass4.input0 = ImagePropertyConvert.output0
  MinMaxScan3.input0 = ProbabilityClass4.output0
  SoView2DOverlay3.image = MinMaxScan3.output0
  EstimatedHistogram.inCurveList = ConcatenateCurves.outCurveList
  MergeRegions.input0 = LocalImage.outImage
  MergeRegions.input1 = LocalImage1.outImage
}
networkModel  {
  parentItems  {
    0  {
      MLABNetworkModelItem MLABNetworkModelItemGroup {
        uniqueId = 79
        objectName = "Assign Class Probabilities"
        parentUniqueId = 0
        color  {
          r = 45
          g = 226
          b = 226
          a = 40
        }
      }
      MLABNetworkModelItem MLABNetworkModelItemGroup {
        uniqueId = 139
        objectName = "Analyze Histogram"
        parentUniqueId = 0
        color  {
          r = 45
          g = 226
          b = 226
          a = 40
        }
      }
      MLABNetworkModelItem MLABNoteItem {
        uniqueId = 85
        objectName = ""
        parentUniqueId = 0
        frame = "1000 -728 628 496"
        backgroundColor  {
          r = 252
          g = 242
          b = 2
          a = 255
        }
        text = "- How is k-means clustering usually initialized?
In our EM implementation, we initialize similarly:

initial_mean = x_minimum + (class_id + 0.5) * data_range / NUMBER_OF_CLASSES

This spreads initial means evenly across the histogram range, like placing centroids evenly in the data space.

- How is the fuzziness controlled in the fuzzy clustering algorithm?

We calculate soft assignments

normalized_prob = class_likelihoods[class_idx] / total_likelihood
class_responsibilities[class_idx][bin_idx] = observed_count * normalized_prob

The responsibilities act like fuzzy memberships, each data point can partially belong to multiple classes. The Gaussian distributions naturally create soft boundaries between classes."
        richText = "*<html>
  <head>
    <style type="text/css">
      a.headerlink {
        visibility: hidden;
      }
      table {
        border-collapse: collapse;
      }
    </style>
  </head>
  <body>

  <ul class="simple">
<li>How is k-means clustering usually initialized?</li>
</ul>
<p>In our EM implementation, we initialize similarly:</p>
<p>initial_mean = x_minimum + (class_id + 0.5) * data_range / NUMBER_OF_CLASSES</p>
<p>This spreads initial means evenly across the histogram range, like placing centroids evenly in the data space.</p>
<ul class="simple">
<li>How is the fuzziness controlled in the fuzzy clustering algorithm?</li>
</ul>
<p>We calculate soft assignments</p>
<p>normalized_prob = class_likelihoods[class_idx] / total_likelihood
class_responsibilities[class_idx][bin_idx] = observed_count * normalized_prob</p>
<p>The responsibilities act like fuzzy memberships, each data point can partially belong to multiple classes. The Gaussian distributions naturally create soft boundaries between classes.</p>


  </body>
</html>*"
        titleText = Questions
        isCollapsed = False
        drawAsComment = False
        titleFrame = "1005 -723 618 22"
      }
    }
  }
}
